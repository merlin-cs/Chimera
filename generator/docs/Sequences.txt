Theory Reference: Sequences

Note

cvc5 currently only supports sequences where the element sort either has an infinite domain, e.g., sequences of integers, or a finite domain of a fixed cardinality, e.g. bit-vectors.
Semantics

* (seq.empty (Seq S))

  ⟦seq.empty⟧ = []

* (seq.unit S (Seq S))

  ⟦seq.unit⟧(x) = [x]

* (seq.len (Seq S) Int)

  ⟦seq.len⟧(s) is the length of the sequence s, denoted as |s|.

* (seq.nth ((Seq S) Int) S)

  ⟦seq.nth⟧(s, i) is the n-th element in the sequence s,
                  denoted as nth(s, i).
                  It is uninterpreted if i out of bounds,
                  i.e. i < 0 or i >= |s|.

* (seq.update ((Seq S) Int (Seq S)) (Seq S))

  ⟦seq.update⟧(s, i, sub) is a sequence obtained by updating the continuous
                          sub-sequence of s starting at index i by sub.
                          The updated sequence has the same length as |s|.
                          If i + |sub| > |s|,
                          the out of bounds part of sub is ignored.
                          If i out of bounds, i.e. i < 0 or i >= |s|,
                          the updated sequence remains same with s.

* (seq.extract ((Seq S) Int Int) (Seq S))

  ⟦seq.extract⟧(s, i, j) is the maximal sub-sequence of s that starts at
                         index i and has length at most j,
                         in case both i and j are non-negative and i is
                         smaller than |s|.
                         Otherwise, the return value is the empty sequence.

 * (seq.++ ((Seq S) (Seq S)) (Seq S))

  ⟦seq.++⟧(s1, s2) is a sequence that is the concatenation of s1 and s2.

 * (seq.at ((Seq S) Int) (Seq S))

  ⟦seq.at⟧(s, i) is a unit sequence that contains the i-th element of s as
                 the only element, or is the empty sequence if i < 0 or i > |s|.

 * (seq.contains ((Seq S) (Seq S)) Bool)

  ⟦seq.contains⟧(s, sub) is true if sub is a continuous sub-sequence of s,
                         i.e. sub = seq.extract(s, i, j) for some i, j,
                         and false if otherwise.

 * (seq.indexof ((Seq S) (Seq S) Int) Int)

  ⟦seq.indexof⟧(s, sub, i) is the first position of sub at or after i in s,
                           and -1 if there is no occurrence.

 * (seq.replace ((Seq S) (Seq S) (Seq S)) (Seq S))

  ⟦seq.replace⟧(s, src, dst) is the sequence obtained by replacing the
                             first occurrence of src by dst in s.
                             It is s if there is no occurrence.

 * (seq.replace_all ((Seq S) (Seq S) (Seq S)) (Seq S))

  ⟦seq.replace_all⟧(s, src, dst) is the sequence obtained by replacing all
                                 the occurrences of src by dst in s,
                                 in the order from left to right.
                                 It is s if there is no occurrence.

 * (seq.rev (Seq S) (Seq S))

  ⟦seq.rev⟧(s) is the sequence obtained by reversing s.

 * (seq.prefixof ((Seq S) (Seq S)) Bool)

  ⟦seq.prefixof⟧(pre s) is true if pre is a prefix of s, false otherwise.

 * (seq.suffixof ((Seq S) (Seq S)) Bool)

  ⟦seq.suffixof⟧(suf s) is true if suf is a suffix of s, false otherwise.

  Syntax

For the C++ API examples in the table below, we assume that we have created a Solver object solver.

<tbody>
<tr class="row-odd"><td></td>
<td><p>SMT-LIB language</p></td>
<td><p>C++ API</p></td>
</tr>
<tr class="row-even"><td><p>Logic String</p></td>
<td><p>use <cite>S</cite> for sequences and strings</p>
<p><code class="docutils literal notranslate"><span class="pre">(set-logic</span> <span class="pre">QF_SLIA)</span></code></p>
</td>
<td><p>use <cite>S</cite> for sequences and strings</p>
<p><code class="docutils literal notranslate"><span class="pre">solver.setLogic(&quot;QF_SLIA&quot;);</span></code></p>
</td>
</tr>
<tr class="row-odd"><td><p>Sort</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(Seq</span> <span class="pre">&lt;Sort&gt;)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">solver.mkSequenceSort(&lt;Sort&gt;);</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Constants</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(declare-const</span> <span class="pre">X</span> <span class="pre">(Seq</span> <span class="pre">Int))</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">solver.mkSequenceSort(solver.getIntegerSort());</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">solver.mkConst(s,</span> <span class="pre">&quot;X&quot;);</span></code></p>
</td>
</tr>
<tr class="row-odd"><td><p>Empty sequence</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(as</span> <span class="pre">seq.empty</span> <span class="pre">(Seq</span> <span class="pre">Int))</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">intSort</span> <span class="pre">=</span> <span class="pre">solver.getIntegerSort();</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkEmptySequence(intSort);</span></code></p>
</td>
</tr>
<tr class="row-even"><td><p>Unit sequence</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.unit</span> <span class="pre">1)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_UNIT,</span> <span class="pre">{solver.mkInteger(1)});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Sequence length</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.len</span> <span class="pre">X)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_LENGTH,</span> <span class="pre">{X});</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Element access</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.nth</span> <span class="pre">X</span> <span class="pre">i)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_NTH,</span> <span class="pre">{X,</span> <span class="pre">i});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Element update</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.update</span> <span class="pre">X</span> <span class="pre">i</span> <span class="pre">Y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_UPDATE,</span> <span class="pre">{X,</span> <span class="pre">i,</span> <span class="pre">Y});</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Extraction</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.extract</span> <span class="pre">X</span> <span class="pre">i</span> <span class="pre">j)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_EXTRACT,</span> <span class="pre">{X,</span> <span class="pre">i,</span> <span class="pre">j});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Concatenation</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.++</span> <span class="pre">X</span> <span class="pre">Y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_CONCAT,</span> <span class="pre">{X,</span> <span class="pre">Y});</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Sub-sequence with
single element</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.at</span> <span class="pre">X</span> <span class="pre">i)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_AT,</span> <span class="pre">{X,</span> <span class="pre">i});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Sequence containment</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.contains</span> <span class="pre">X</span> <span class="pre">Y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_CONTAINS,</span> <span class="pre">{X,</span> <span class="pre">Y});</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Sequence indexof</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.indexof</span> <span class="pre">X</span> <span class="pre">Y</span> <span class="pre">i)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_INDEXOF,</span> <span class="pre">{X,</span> <span class="pre">Y,</span> <span class="pre">i});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Sub-sequence replace</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.replace</span> <span class="pre">X</span> <span class="pre">Y</span> <span class="pre">Z)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_REPLACE,</span> <span class="pre">{X,</span> <span class="pre">Y,</span> <span class="pre">Z});</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Sub-sequence
replace all</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.replace_all</span> <span class="pre">X</span> <span class="pre">Y</span> <span class="pre">Z)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_REPLACE_ALL,</span> <span class="pre">{X,</span> <span class="pre">Y,</span> <span class="pre">Z});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Sequence reverse</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.rev</span> <span class="pre">X)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_REV,</span> <span class="pre">{X});</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Sequence prefix of</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.prefixof</span> <span class="pre">X</span> <span class="pre">Y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_PREFIX,</span> <span class="pre">{X,</span> <span class="pre">Y});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Sequence suffix of</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(seq.suffixof</span> <span class="pre">X</span> <span class="pre">Y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::SEQ_SUFFIX,</span> <span class="pre">{X,</span> <span class="pre">Y});</span></code></p></td>

Examples
```
(set-logic QF_SLIA)
(set-info :status unsat)
(declare-fun x () (Seq Int))
(declare-fun y () (Seq Int))
(declare-fun z () (Seq Int))
(declare-fun a () Int)
(declare-fun b () Int)
(assert (= y (seq.update x 0 (seq.unit a))))
(assert (= z (seq.update x 0 (seq.unit b))))
(assert (not (= a b)))
(assert (= y z))
(assert (> (seq.len y) 0))
(check-sat)
```
```
(set-logic QF_SLIA)
(set-info :status unsat)
(declare-fun A () (Seq Int))
(declare-fun S () (Seq Int))
(declare-fun i () Int)
(assert (<= 0 i))
(assert (< i (- (seq.len A) 1)))
(assert (= S (seq.extract A i 1)))
(assert (distinct (seq.nth S 0) (seq.nth A i)))
(check-sat)
```
```
(set-logic QF_SLIA)
(set-info :status unsat)
(declare-fun x () (Seq Int))
(declare-fun y () (Seq Int))
(declare-fun a () Int)
(declare-fun b () Int)
(assert (= (seq.++ (seq.unit a) y) (seq.update x 0 (seq.unit b))))
(assert (not (= a b)))
(check-sat)
```