<h1>Theory Reference: Finite Fields<a class="headerlink" href="#theory-reference-finite-fields" title="Link to this heading"></a></h1>
<div class="admonition note">
<p class="admonition-title">Note</p>
<dl class="simple">
<dt>Currently, cvc5 only supports finite fields of prime order p.</dt><dd><p>Such a field is isomorphic to the integers modulo p.</p>
</dd>
</dl>
</div>
<section id="semantics">
<h2>Semantics<a class="headerlink" href="#semantics" title="Link to this heading"></a></h2>
<p>First, for integer <span class="math notranslate nohighlight">\(x\)</span> and positive integer <span class="math notranslate nohighlight">\(y\)</span>, define <span class="math notranslate nohighlight">\((x \bmod y)\)</span> as the unique integer <span class="math notranslate nohighlight">\(r\)</span> such that <span class="math notranslate nohighlight">\(y = qx + r\)</span> (where <span class="math notranslate nohighlight">\(q\)</span> is an integer) and <span class="math notranslate nohighlight">\(0 \le r &lt; q\)</span>.
NB: This is the remainder when so-called “floor division” is performed.</p>
<p>We interpret field sorts as prime fields and field terms as integers. In the following, let:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> be an integer numeral and <span class="math notranslate nohighlight">\(N\)</span> be its integer</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">p</span></code> be a prime numeral and <span class="math notranslate nohighlight">\(p\)</span> be its prime</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">F</span></code> be an SMT field sort (of order <span class="math notranslate nohighlight">\(p\)</span>)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> be SMT field terms (of the same sort <code class="docutils literal notranslate"><span class="pre">F</span></code>) with interpretations <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span></p></li>
</ul>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>SMT construct</p></th>
<th class="head"><p>Semantics</p></th>
<th class="head"><p>Notes</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">FiniteField</span> <span class="pre">p)</span></code></p></td>
<td><p>the field of order <span class="math notranslate nohighlight">\(p\)</span></p></td>
<td><p>represented as the integers modulo <span class="math notranslate nohighlight">\(p\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">(as</span> <span class="pre">ffN</span> <span class="pre">F)</span></code></p></td>
<td><p>the integer <span class="math notranslate nohighlight">\((N \bmod p)\)</span></p></td>
<td></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">(ff.add</span> <span class="pre">x</span> <span class="pre">y)</span></code></p></td>
<td><p>the integer <span class="math notranslate nohighlight">\(((x + y) \bmod p)\)</span></p></td>
<td><p>NB: <code class="docutils literal notranslate"><span class="pre">ff.add</span></code> is an n-ary operator</p></td>
</tr>
<tr class="row-odd"><td><p><code class="docutils literal notranslate"><span class="pre">(ff.mul</span> <span class="pre">x</span> <span class="pre">y)</span></code></p></td>
<td><p>the integer <span class="math notranslate nohighlight">\(((x \times y) \bmod p)\)</span></p></td>
<td><p>NB: <code class="docutils literal notranslate"><span class="pre">ff.mul</span></code> is an n-ary operator</p></td>
</tr>
<tr class="row-even"><td><p><code class="docutils literal notranslate"><span class="pre">(=</span> <span class="pre">x</span> <span class="pre">y)</span></code></p></td>
<td><p>the Boolean <span class="math notranslate nohighlight">\(x = y\)</span></p></td>
<td></td>
</tr>
</tbody>
</table>
</section>
<section id="syntax">
<h2>Syntax<a class="headerlink" href="#syntax" title="Link to this heading"></a></h2>
<p>For the C++ API examples in the table below, we assume that we have created
a <a class="reference internal" href="../api/cpp/classes/solver.html#_CPPv4N4cvc56SolverE" title="cvc5::Solver"><code class="xref cpp cpp-class docutils literal notranslate"><span class="pre">Solver</span></code></a> object <code class="docutils literal notranslate"><span class="pre">solver</span></code>.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"></th>
<th class="head"><p>SMT-LIB language</p></th>
<th class="head"><p>C++ API</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>Logic String</p></td>
<td><p>use <cite>FF</cite> for finite fields</p>
<p><code class="docutils literal notranslate"><span class="pre">(set-logic</span> <span class="pre">QF_FF)</span></code></p>
</td>
<td><p>use <cite>FF</cite> for finite fields</p>
<p><code class="docutils literal notranslate"><span class="pre">solver.setLogic(&quot;QF_FF&quot;);</span></code></p>
</td>
</tr>
<tr class="row-odd"><td><p>Sort</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(_</span> <span class="pre">FiniteField</span> <span class="pre">&lt;Prime</span> <span class="pre">Order&gt;)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">solver.mkFiniteFieldSort(&lt;Prime</span> <span class="pre">Order</span> <span class="pre">As</span> <span class="pre">String&gt;);</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Constants</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(declare-const</span> <span class="pre">X</span> <span class="pre">(_</span> <span class="pre">FiniteField</span> <span class="pre">7))</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">s</span> <span class="pre">=</span> <span class="pre">solver.mkFiniteFieldSort(&quot;7&quot;);</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">X</span> <span class="pre">=</span> <span class="pre">solver.mkConst(s,</span> <span class="pre">&quot;X&quot;);</span></code></p>
</td>
</tr>
<tr class="row-odd"><td><p>Finite Field Value</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(as</span> <span class="pre">ff3</span> <span class="pre">(_</span> <span class="pre">FiniteField</span> <span class="pre">7))</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Sort</span> <span class="pre">ffSort</span> <span class="pre">=</span> <span class="pre">solver.mkFiniteFieldSort(&quot;7&quot;);</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkFiniteFieldElem(&quot;3&quot;,</span> <span class="pre">ffSort);</span></code></p>
</td>
</tr>
<tr class="row-even"><td><p>Addition</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(ff.add</span> <span class="pre">x</span> <span class="pre">y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::FINITE_FIELD_ADD,</span> <span class="pre">{x,</span> <span class="pre">y});</span></code></p></td>
</tr>
<tr class="row-odd"><td><p>Multiplication</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(ff.mul</span> <span class="pre">x</span> <span class="pre">y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::FINITE_FIELD_MULT,</span> <span class="pre">{x,</span> <span class="pre">y});</span></code></p></td>
</tr>
<tr class="row-even"><td><p>Equality</p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">(=</span> <span class="pre">x</span> <span class="pre">y)</span></code></p></td>
<td><p><code class="docutils literal notranslate"><span class="pre">Term</span> <span class="pre">t</span> <span class="pre">=</span> <span class="pre">solver.mkTerm(Kind::EQUAL,</span> <span class="pre">{x,</span> <span class="pre">y});</span></code></p></td>
</tr>
</tbody>
</table>
</section>
<section id="examples">
<h2>Examples<a class="headerlink" href="#examples" title="Link to this heading"></a></h2>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="k">set-logic</span> <span class="n">QF_FF</span>)
(<span class="k">set-info</span> <span class="na">:status</span> <span class="n">unsat</span>)
(<span class="k">define-sort</span> <span class="n">F</span> () (<span class="na">_</span> <span class="n">FiniteField</span> <span class="m">3</span>))
(<span class="k">declare-const</span> <span class="n">x</span> <span class="n">F</span>)
(<span class="k">assert</span> (<span class="o">=</span> (<span class="n">ff.mul</span> <span class="n">x</span> <span class="n">x</span>) (<span class="k">as</span> <span class="n">ff-1</span> <span class="n">F</span>)))
(<span class="k">check-sat</span>)
<span class="c">; unsat</span>
</pre></div>
</div>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="k">set-logic</span> <span class="n">QF_FF</span>)
(<span class="k">set-info</span> <span class="na">:status</span> <span class="n">sat</span>)
(<span class="k">define-sort</span> <span class="n">F</span> () (<span class="na">_</span> <span class="n">FiniteField</span> <span class="m">3</span>))
(<span class="k">declare-const</span> <span class="n">x</span> <span class="n">F</span>)
(<span class="k">assert</span> (<span class="o">=</span> (<span class="n">ff.mul</span> <span class="n">x</span> <span class="n">x</span>) (<span class="k">as</span> <span class="n">ff0</span> <span class="n">F</span>)))
(<span class="k">check-sat</span>)
<span class="c">; sat: (= x (as ff0 F)) is the only model</span>
</pre></div>
</div>
<div class="highlight-smtlib notranslate"><div class="highlight"><pre><span></span>(<span class="k">set-logic</span> <span class="n">QF_FF</span>)
(<span class="k">set-info</span> <span class="na">:status</span> <span class="n">unsat</span>)
(<span class="k">define-sort</span> <span class="n">F</span> () (<span class="na">_</span> <span class="n">FiniteField</span> <span class="m">3</span>))
(<span class="k">declare-const</span> <span class="n">x</span> <span class="n">F</span>)
(<span class="k">declare-const</span> <span class="n">y</span> <span class="n">F</span>)
(<span class="k">declare-const</span> <span class="n">z</span> <span class="n">F</span>)
(<span class="k">assert</span> (<span class="o">=</span> (<span class="n">ff.mul</span> (<span class="n">ff.add</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>) (<span class="n">ff.add</span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span>)) (<span class="k">as</span> <span class="n">ff-1</span> <span class="n">F</span>)))
(<span class="k">check-sat</span>)
<span class="c">; unsat</span>
</pre></div>
</div>
</section>
<section id="experimental-extensions">
<h2>Experimental Extensions<a class="headerlink" href="#experimental-extensions" title="Link to this heading"></a></h2>
<p>These features of the theory are experimental; they may be removed in the
future:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">ff.bitsum</span></code>: an n-ary operator for bitsums: <code class="docutils literal notranslate"><span class="pre">(ff.bitsum</span> <span class="pre">x0</span> <span class="pre">x1</span> <span class="pre">x2)</span></code> is equivalent to <span class="math notranslate nohighlight">\(x_0 + 2x_1 + 4x_2\)</span>.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ff.neg</span></code>: unary negation</p></li>
</ul>
</section>
<section id="solvers">
<h2>Solvers<a class="headerlink" href="#solvers" title="Link to this heading"></a></h2>
<p>Internally, cvc5 implements two solvers for the theory of finite fields.</p>
<ul class="simple">
<li><p>The default solver is described in “Satisfiability Modulo Finite Fields” <span id="id1">[<a class="reference internal" href="../references.html#id16" title="Alex Ozdemir, Gereon Kremer, Cesare Tinelli, and Clark Barrett. Satisfiability modulo finite fields. In Constantin Enea and Akash Lal, editors, Computer Aided Verification (CAV), volume 13965 of Lecture Notes in Computer Science, 163–186. Springer, 2023. URL: https://doi.org/10.1007/978-3-031-37703-7_8, doi:10.1007/978-3-031-37703-7_8.">OKTB23</a>]</span>.</p></li>
<li><p>The <code class="docutils literal notranslate"><span class="pre">--ff-solver</span> <span class="pre">split</span></code> flag turns on an alternate solver from “Split Groebner Bases for Satisfiability Modulo Finite Fields” <span id="id2">[<a class="reference internal" href="../references.html#id17" title="Alex Ozdemir, Shankara Pailoor, Alp Bassa, Kostas Ferles, Clark Barrett, and Işıl Dillig. Split gröbner bases for satisfiability modulo finite fields. In Computer Aided Verification (CAV), Lecture Notes in Computer Science. 2024. URL: https://ia.cr/2024/572.">OPB+24</a>]</span>. This solver may be better on field equations that encode bit-decomposition. See the paper for more information.</p></li>